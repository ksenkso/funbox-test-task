# Ответы на вопросы (Level 1)

## Q1

> Расскажите, чем, на ваш взгляд, отличается хорошее клиентское приложение от
плохого с точки зрения
> - пользователя;
> - менеджера проекта;
> - дизайнера;
> - верстальщика;
> - серверного программиста.

Для пользователя различия между хорошим и плохим приложениями состоят в качестве UI и UX.
Хорошее клиентское приложение предлагает простой интерфейс, использующий распространённые формы взаимодействия
с пользователем. Простота интерфейса складывается из нескольких характеристик:

- количество различных элементов;
- узнаваемость этих элементов;
- количество способов сделать одно и то же действие;
- количество действий, необходимых для достижения результата.

Чем больше элементов на экране, тем сложнее найти нужный. В плохом приложении интерфейс перегружен - он предлагает
пользователю так много действий, что тот не может быстро понять, что именно ему нужно. Такой интерфейс может сильно влиять
на желание пользоваться приложением, вплоть до полного отказа от него. Хорошее приложение показывает пользователю только
то, что может ему пригодиться в данный момент - на текущем экране, в текущем состоянии. 

Наверняка можно добавить к этим характеристикам и другие, например, размер элементов управления. И тут мы подходим к
понятию пользовательского опыта. В этом аспекте важно учитывать скорость загрузки, отзывчивость приложения, адаптивность
и доступность. Хорошее приложение работает быстро и ведёт себя ожидаемо для пользователя, в отличие от плохого, которое
работает с притормаживаниями и использует нестандартные элементы управления.

Последние два пункта тесно связаны, так как они оба имеют отношение к навигации в приложении. Они описывают баланс между
удобством и хаосом. Так, в хорошем приложении, если у пользователя в процессе работы часто возникает задача перехода с
одного экрана на второй через несколько других экранов, то на первом должна быть ссылка на второй. Это делает процесс
работы более выраженным и пользователю легче к нему привыкнуть, а также это просто быстрее. В плохом приложении такой ссылки
просто нет, что требует от пользователя дольше держать в голове его задачу, не выполняя её.

С другой стороны, в хорошем приложении такие ссылки есть только там, где это необходимо. Возможность перехода с любого
экрана на любой или просто очень высокая связность навигации запутывает пользователя. Из-за этого появляются длинные, 
ветвистые меню, которые хоть и уменьшают количество кликов, но снижают запоминаемость порядка действий - в длинном списке
труднее найти нужное.

Ну и конечно же, в приложении должно быть как можно меньше багов и они должны встречаться как можно реже.

С точки зрения менеджера проекта хорошее приложение должно быть прогнозируемым в разработке и развитии. Разработка должна
быть прозрачной, чтобы её можно было качественно планировать. Для плохого приложения трудно что-либо запланировать - 
разработчики не могут оценивать сроки, они постоянно перегружены, а задачи не разделены по приоритетам. Различные методологии
разработки предлагают разные решения для этих проблем. Но все они нацелены на то, чтобы дать некоторые гарантии, опираясь
на которые, менеджеры и разработчики смогут планировать новые возможности, исправление, решение технических и других задач.

Помимо планирования, менеджеру также важно понимать, как приложение используется. В хорошем приложении есть системы аналитики
и пользовательского фидбека, которые помогают определить проблемы и найти курс развития. Без понимания этих вещей трудно
узнать реальные потребности пользователей и проблемы, с которыми они сталкиваются. Плохое приложение игнорирует запросы
пользователей, а хорошее - адаптируется под них.

Возвращаясь к визуальной части, с точки зрения дизайнера, хорошее приложение имеет свой язык. Этот язык обычно выражается
через дизайн-систему - совокупность внешнего вида различных компонентов, цветовой гаммы, способов взаимодействия с пользователем
и многого другого. Приложение должно восприниматься как единое целое. В отсутствие такой системы дизайнеру каждый раз при
создании макета приходится думать о том, откуда взять компоненты, какого размера они должны быть, какие цвета можно
использовать и т.д. Все эти вопросы отнимают время и отвлекают от основной задачи - проектирования удобного UI.

Наличие одной только системы компонентов решает вопрос того, как выглядит тот или иной элемент дизайна. Без этого каждый экран
приложения будет отличаться от других, не будет создаваться ощущения системности и стабильности. В плохом приложении её
вообще трудно организовать - мешают требования ТЗ по внешнему виду, или же сами фичи спроектированы так, что не вписываются
в существующую систему. В хорошем приложении проектирование производится с учётом существующего дизайна и, при необходимости,
планируется его расширение максимально естественным для системы образом.

Для верстальщика также важно наличие дизайн-системы хоть в каком-то виде. Но так же важно и то, какими создаются дизайн-макеты.
Хорошее приложение легко разбивается на блоки, которые удобно верстать, а так же переиспользовать. В плохом приложении
каждый экран уникален, но только из-за мелочей. Это накладывает дополнительные затраты по времени и делает разработку
менее предсказуемой.

У хорошего адаптивного приложения основной макет легко перенести на другие экраны - в этом опять же помогает блочность и
наличие дизайн-системы. Причём это реализуется с одной и той же вёрсткой. В плохом приложении будет использована или
дублирующая вёрстка, или полностью отдельная версия тогда, когда в этом нет необходимости. Но бывает и такое, что приложение
слишком сложное, чтобы быть таким адаптивным (VK, Facebook).

В целом, модульность, системность и наличие подходящих инструментов разработки и отличают хорошее приложение от плохого
в глазах верстальщика. Что-то похожее можно сказать и о взгляде серверных программистов. Так как в их задачи входит
обеспечение быстрого, удобного и понятного взаимодействия клиента и сервера, хорошее клиентское приложение должно отвечать
тем же.

Хорошее клиентское приложение использует ресурсы сервера с оглядкой на производительность - важна скорость ответа, частота
запросов и нагрузка на сервер с каждым запросом. Можно сказать, что плохое приложение думает только о себе, отправляя
сотни запросов на один сервер и пренебрегая кешированием.

Важно также и разделение ресурсов приложения. Какие-то из них статические и не требуют работы сервера приложений. Другие
наоборот, представляют собой динамические данные. Разделение этих типов данных позволяет разгрузить одни сервера и загрузить
другие, оптимизируя не только время ответа, но и расходы на их содержание - обычно сервера статики дешевле, чем сервера
приложений.

## Q2

> Опишите основные особенности разработки крупных многостраничных сайтов,
функциональность которых может меняться в процессе реализации и поддержки.
> 
> Расскажите о своем опыте работы над подобными сайтами: какие подходы,
инструменты и технологии вы применяли на практике, с какими проблемами
сталкивались и как их решали.

В динамично развивающихся приложениях можно выделить несколько особенностей, связанных с изменением функциональности:

- низкий уровень шаблонизации;
- большая изолированность компонентов сайта;
- предпочтение композиции компонентов расширению.
- использование собственных разработок вместо готовых решений;

Вместо создания сложных компонентов, решающих задачи заранее определённым образом, компоненты в таких системах обычно
собираются под конкретные задачи из маленьких частей. Так становится возможным добавлять им поведение, требуемое для задачи,
хотя нельзя сказать, что так стоит делать всегда. Шаблоны тоже нужны, но они должны быть гибкими - иметь много настроек,
а также иметь как можно меньше жёстких зависимостей и ограничений.

Маленькие компоненты должны быть по большей мере самостоятельными. Так их можно будет легко добавить из одного модуля в
другой, а все их зависимости должны быть достаточно очевидны для того, чтобы найти и перенести их тоже.

Эти два фактора приводят нас к тому, что для часто меняющихся систем выгоднее использовать композицию компонентов, чем
создавать большие, богатые функциональностью абстрактные компоненты. Их использование приводит к тому, что в случае появления
нестандартной задачи придётся или написать новый большой компонент под новый кейс, или сломать существующую систему и сделать
задачу с помощью хаков, или вообще отказаться от неё. Но опять же, в системе обычно есть более стабильные и менее стабильные
части. Более стабильные могут выполнять больше работы и быть менее гибкими, чтобы придавать системе форму. 

Кастомизация касается и готовых решений. Даже если такой сайт разрабатывается на популярной CMS, которая содержит много
шаблонов и возможностей, велика вероятность того, что её придётся дорабатывать. Использование собственных разработок
позволяет обеспечить большую гибкость системы и её направленность на конкретные задачи бизнеса.

Помимо этих особенностей, можно также отметить частое использование готовых ручных сборок, feature-флагов и конфигураций,
экспериментальных возможностей и A/B-тестов. Эти инструменты помогают собирать продукт по-разному, в зависимости от
потребностей пользователей и других задач (ограничения, аналитика, эксперименты).

На своём опыте я использовал систему с конфигурацией, которая позволяла подключать модули для отдельных пользователей.
Она позволяла не только ограничивать доступ, но и осуществлять бета-тестирование готовящихся к выпуску модулей. Это
позволяло собрать отзывы и внести необходимые корректировки в релизную версию. 

Также мне довелось разрабатывать новую функциональность для системы, требования к которой были неполными и
часто изменялись. Нужно было разрабатывать несколько таблиц с динамическими данными и фильтрами по различным признакам,
а также формы для внесения данных в эти таблицы. Набор полей, их назначение, названия и форматы изменялись несколько раз.
Так как я участвовал в обсуждениях этих задач, я знал о том, что таки изменения будут происходить и проектировал компоненты
так, чтобы можно было добавить элементам таблиц особенное поведение и стили, добавлять и изменять фильтры и их поведение,
изменять состав форм и добавлять эти формы на другие страницы.

Для этого нужно было правильно определять зависимости каждого компонента. Я старался следовать принципу ISP - выделять
минимальный интерфейс для зависимостей, чтобы при изменении вышестоящего компонента можно было легко подстроить его данные
под нужный формат. Помимо этого, я старался не держать бизнес-логику в компонентах. На проекте использовались Vue.js + Vuex,
поэтому логика работы фильтров была в сторе, но валидации и загрузку данных форм было решено оставить в компонентах форм.
Реализация реактивных форм в проекте была своей и валидации нужно было привязывать к компоненту, поэтому данные и логику
работы с ними было решено оставить там.

Помимо этого случая были и другие, когда приходилось менять функциональность достаточно часто. Например, в одной из частей
финансового модуля той же системы нужно было проводить эксперименты по работе скидочных систем. Для этого создавались текстовые
описания того, как системы должны работать и по ним выстраивалась разработка. В этом процессе так же помогало отделение
логики от представления и выделение минимально-необходимого интерфейса.

## Q3

> При разработке интерфейсов с использованием компонентной архитектуры часто
используются термины **Presentational Components** и **Container Components**. Что
означают данные термины? Зачем нужно такое разделение, какие у него есть плюсы и
минусы?

Container Components - компоненты, которые отвечают за загрузку и обработку данных.
Presentational Components - компоненты, которые отвечают за отображение этих данных.

Такое разделение помогает не смешивать ответственность внутри одного компонента. Такие компоненты проще переиспользовать,
рефакторить и изменять в целом. Ответственность контейнеров - взаимодействие с сервером, предварительная и постобработка
данных, работа со стейт-менеджером и т.д. Их разметка обычно минимальна и нужна только для того, чтобы правильно организовать
presentational-компоненты. Их же ответственность как раз состоит в том, чтобы отображать UI.

Так, к плюсам можно отнести:

- разделение ответственности;
- переиспользуемость разметки;
- возможность отдельно тестировать логику и представление.

Из минусов же можно выделить то, что из-за такого разделения появляется большое количество компонентов-обёрток.
Это негативно влияет на процесс отладки, а так же может влиять и на производительность. Ещё одной проблемой может стать
props-hell. Из-за высокой вложенности presentational-компонентов может возникнуть ситуация, когда контейнер, хранящий
некоторое состояние, должен передать его компоненту в глубине дерева потомков. Из-за этого у компонентов между ними
появляются свойства, которые они не используют сами, а просто передают дальше. Однако, это решается с помощью различных
реализаций контекста в разных фреймворках, стейт-менеджеров и обеспечения возможности замены контента в компонентах.

## Q4

> Как устроено наследование в JS? Расскажите о своем опыте реализации JS-наследования без использования фреймворков.

Стоит начать с того, как в JS создаются объекты. У каждого объекта есть функция-конструктор. С помощью неё задаётся
определение класса объекта. До стандарта ES2015 это было единственным способом объявить класс. Выглядело это так:

```javascript
function Person(name) {
    this.name = name;
}

Person.prototype.greet = function() {
    console.log("Hello, my name is " + this.name);
}
```
Методы, которые должны быть доступны объектам (методы инстансов), объявляются на прототипе функции-конструктора.
Чтобы создать объект, нужно вызвать конструктор с оператором `new`:

```javascript
var person = new Person('Kostya');
person.greet(); // выведет Hello, my name is Kostya 
```

Метод `greet` становится доступен объекту `person` через цепочку прототипов. При его вызове, движок JS сначала проверит,
есть ли ключ с таким именем у самого объекта. Если его нет, то он будет подниматься по цепочке прототипов. При создании
объекта, оператор new устанавливает для него ссылку `__proto__` на свойство `prototype` функции-конструктора. А там метод
`greet` уже есть. Как только ключ найден, поиск завершается и происходит вызов метода. У обычных функций в JS есть объект
контекста, который определяется при вызове (помимо случаев использования `bind`). При вызове метода у объекта это объект
становится контекстом вызова. Таким образом, мы можем один раз определить метод в прототипе и вызывать его на разных объектах.
Каждый раз `this` будет ссылаться на тот объект, на котором вызван метод.

Для того чтобы организовать наследование в JS, нужно поработать с прототипами. До появления ключевых слов `class` и `extends`
механизм наследования приходилось реализовывать самостоятельно. Чтобы унаследовать класс `A` от класса `B`, нужно
сделать так, чтобы прототип `A` был объектом со ссылкой `__proto__` на прототип `B`:

```javascript
function inherit(targetClass, parentClass) {
    targetClass.prototype = Object.create(parentClass.prototype);
    // также нужно не забыть исправить ссылку на конструктор класса,
    // чтобы пользоваться статическими методами через this.constructor
    targetClass.prototype.constructor = targetClass
}
```

## Q5

> Какие библиотеки можно использовать для написания тестов end-to-end во
фронтенде? Расскажите о своем опыте тестирования веб-приложений.

К наиболее популярным решениям можно отнести Cypress, Playwright, TestCafe, Puppeteer и различные связки с Selenium.

На предыдущей работы я использовал Capybara и Selenium для e2e-тестов. В команде не было принято писать автоматизированные
тесты, но так как система была достаточно сложной, они были необходимы хотя бы для предотвращения регрессов. Поэтому я
активно продвигал идею внедрения автотестов на уровне e2e, так как основные сложности в работе вызывали именно поведенческие
регрессы в сложных сценариях. Из-за высокой загруженности всей команды при мне внедрить тесты не успели, но их проект
остался.

Также, я внедрял и unit-тесты на фронтенде для приложения на Vue 3 + TypeScript с использованием Jest и Sinon.
Sinon использовался для подмены методов библиотеки rest api, jest - test-runner, библиотека сопоставлений, создание снэпшотов,
подсчёт покрытия. Для тестирования компонентов использовалась `@vue/test-utils`. Однако этот проект тоже ещё не вышел в
релиз и тестов на нём было мало. Проводя эту работу я больше концентрировался на том, чтобы создать примеры тестов и
подвести других разработчиков к их написанию. Поэтому я проводил звонки с демонстрациями того, как устроены тесты на Selenium
и Jest.

## Q6

> Вам нужно реализовать форму для отправки данных на сервер, состоящую из
нескольких шагов. В вашем распоряжении дизайн формы и статичная верстка, в
которой не показано, как форма должна работать в динамике. Подробного описания,
как должны вести себя различные поля в зависимости от действий пользователя, в
требованиях к проекту нет. Ваши действия?

В такой ситуации можно выделить несколько проблемных мест:

- сложные данные;
- сохранение состояния формы между шагами;
- валидации, подсказки, анимации.

Сначала нужно определить, что требуется для работы формы. Возможно, у неё есть зависимости в виде данных для выпадающих
списков, конфигурации приложения, наличия прав у пользователя или чего-то ещё. Чтобы это выяснить, нужно обратить внимание
на то, какие именно данные заполняются в форме, они могут подсказать об этом. Если возникают сомнения по поводу того, всегда
ли может быть показано какое-то поле, стоит обратиться к тому, кто или знает задачу лучше (например, к её создателю), или
к тому, кто лучше разбирается в данных формы. Подобные моменты нужно озвучить как можно раньше, чтобы не приходилось
вносить исправления или переделывать форму вовсе.

Так как форма состоит из нескольких шагов, то стоит обратить внимание на необходимость сохранения данных между шагами.
Эта возможность может оказаться ненужной, но упомянуть об этом в задаче стоит. Если же это нужно реализовать, то надо
решить, где хранить эти данные - на клиенте или на сервере. Если на сервере, то нужно подумать о том, чтобы форму можно
было предварительно заполнить.

Форму нужно валидировать перед отправкой. Так как уже известно, какие данные в ней отправляются, можно сделать предположения
о необходимых проверках и сообщениях для пользователя. Если подобные данные встречаются в других формах приложения, можно
посмотреть на существующие реализации форм и взять проверки оттуда. Помимо этого, нужно уточнить, нужны ли какие-то
дополнительные проверки помимо уже известных, если есть сомнения на этот счёт.

Для отправки формы нужно знать куда и в каком формате нужно сделать запрос. Для этого можно обратиться к бэкенд-разработчикам
и согласовать формат обмена данными. Также нужно узнать, есть ли в форме валидации, которые запускаются только на сервере,
например, после отправки данных. Если это так, то нужно обработать ошибки, приходящие с сервера и дать пользователю возможность
их исправить.

Реализовав форму, нужно покрыть её тестами. В них надо обратить внимание на проверки состояния: отображение сообщений
наличие зависимостей после загрузки, сообщений об ошибках и успехе. Также нужно проверить работу особенностей формы:
переход по шагам, сохранение и восстановление данных.

После этого фичу можно отдавать на ревью.

## Q7

> Расскажите, какие инструменты помогают вам экономить время в процессе
написания, проверки и отладки кода.

Для экономии времени на ревью я использую линтеры ESLint и Stylelint. В своих проектах также использую Prettier.
В последние несколько месяцев пользовался TabNine для умного автодополнения кода.

При отладке кода использую Chrome Dev Tools, инструменты разработчика для Vue И React. На предыдущем проекте использовал
byebug для отладки кода на Ruby и Rubocop в качестве линтера.
В качестве инструмента типизации я использую TypeScript в своих проектах. Runtime-проверки мне не требуются, а подсказки
в IDE помогают понять, где могут произойти ошибки. Flow в этом плане, конечно, будет сильнее, но я выбираю TypeScript,
потому что мне не нужна дополнительная строгость, а TS ещё и де-факто стал стандартом типизации в JS-разработке.

Помимо этих инструментов я использовал разные сборщики и таск-раннеры: Webpack, Gulp, Grunt, Vite. Все они позволяют
осуществлять горячую замену модулей и автоматическую перезагрузку страницы при изменениях файлов, что экономит время,
позволяя видеть изменения сразу.

## Q8

> Какие ресурсы вы используете для развития в профессиональной сфере? Приведите
несколько конкретных примеров (сайты, блоги и так далее).
> 
> Какие ещё области знаний, кроме тех, что непосредственно относятся к работе, вам
интересны?

Чтобы быть в курсе новостей веба, я слушаю подкасты Веб-стандартов, FrontendWeekend и UnderJS.
Также ежедневно читаю на Хабре хабы Javascript, Разработка веб-сайтов и Программирование.
Редко, но всё же иногда читаю CSS Tricks и Smashing Magazine.
Иногда читаю и разбираю код популярных JS-библиотек на Github, в основном, чтобы читать больше кода, который писал не я.
Недавно начал решать задачи на leetcode и codewars, чтобы отвлечься от обычных задач и поддерживать алгоритмическое мышление.

Мне интересна популярная математика и физика - иногда смотрю различные лекции, доклады и конференции на русском и английском
языках. В последнее время начал интересоваться устройством и историей автомобилей. Также слежу за технологиями в велоспорте.

## Q9

> Расскажите нам немного о себе и предоставьте несколько ссылок на последние
работы, выполненные вами.

Frontend-разработчик, пишу на в основном на Vue, работал с React, Angular/AngularJS, jQuery.

Начал интересоваться вебом в 2014 году, участвовал в конкурсе WorldSkills в компетенции "Веб-дизайн и разработка",
чемпион Московской области 2017. Также занимался подготовкой участников и был экспертом на региональных этапах.

С 2017 по 2020 годы учился в университете на преподавателя математики и информатики.

Проекты:
- [Платформа для разработки визуальных новелл (сейчас в разработке)](https://github.com/ksenkso/vn-backend);
- [Онлайн-расписание для университета](https://github.com/ksenkso/ggtu-timetable-admin-vue);
- [Интерактивные карты для университета](https://github.com/ksenkso/ggtu-map);
- [Сервис для получения информации по объектам SCP Foundation](https://github.com/ksenkso/scp-api);
- [Клон игры Idle Balls](https://github.com/ksenkso/angular-idle-balls);
- [Библиотека для расчёта возраста - aging](https://github.com/ksenkso/aging).
